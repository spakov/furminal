using System;
using System.Collections.Generic;
using System.IO;

namespace Spakov.EmojiGenerator
{
    internal class Generator
    {
        /// <summary>
        /// The path to <c>emoji-sequences.txt</c>.
        /// </summary>
        private const string EmojiSequencesPath = @"..\EmojiGenerator\Unicode\emoji-sequences.txt";

        /// <summary>
        /// The path to <c>emoji-zwj-sequences.txt</c>.
        /// </summary>
        private const string EmojiZwjSequencesPath = @"..\EmojiGenerator\Unicode\emoji-zwj-sequences.txt";

        /// <summary>
        /// The name of the generated <c>Emoji.cs</c>.
        /// </summary>
        private const string EmojiDotCsPath = "Emoji.cs";

        /// <summary>
        /// The content of the generated <c>Emoji.cs</c>.
        /// </summary>
        private const string EmojiDotCsContent = """
      using System.Collections.Generic;

      /*****************************************************************************/
      /* <auto-generated>                                                          */
      /*   This file was generated by EmojiGenerator.                              */
      /*                                                                           */
      /*   Changes to this file may cause incorrect behavior and will be lost if   */
      /*   the code is regenerated.                                                */
      /* </auto-generated>                                                         */
      /*****************************************************************************/

      namespace {namespace}
      {
          /// <summary>
          /// Contains <see cref="HashSet"/>s containing emoji defined by Unicode.
          /// </summary>
          internal static class Emoji
          {
              /// <summary>
              /// Emoji sequences defined by Unicode.
              /// </summary>
              internal static readonly HashSet<string> s_emojiSequences =
              [
                  {emojiSequences}
              ];

              /// <summary>
              /// Emoji zero-width joiner (ZWJ) sequences defined by Unicode.
              /// </summary>
              internal static readonly HashSet<string> s_emojiZwjSequences =
              [
                  {emojiZwjSequences}
              ];
          }
      }
      """;

        private const string EmojiDotCsContentIndent = "            ";

        private readonly string? _outputPath;
        private readonly string _namespace;

        /// <summary>
        /// Initializes a <see cref="Generator"/>.
        /// </summary>
        /// <param name="outputPath">The generated code output path.</param>
        /// <param name="namespace">The namespace to use for generated
        /// code.</param>
        internal Generator(string? outputPath, string @namespace)
        {
            _outputPath = outputPath;
            _namespace = @namespace;
        }

        /// <summary>
        /// Generates the emoji code.
        /// </summary>
        /// <returns>0 on success or non-zero on failure.</returns>
        internal int Generate()
        {
            HashSet<string> emojiSequences = [];
            HashSet<string> emojiZwjSequences = [];

            if (_outputPath is not null)
            {
                if (!Directory.Exists(_outputPath))
                {
                    Console.Error.WriteLine("Output directory does not exist.");
                    return 1;
                }
            }

            try
            {
                using StreamReader emojiSequencesStream = new(EmojiSequencesPath, new FileStreamOptions() { Access = FileAccess.Read, Mode = FileMode.Open });

                emojiSequences = new EmojiSequencesParser(emojiSequencesStream).Parse();
            }
            catch (IOException e)
            {
                Console.Error.WriteLine($"Unable to read from {EmojiSequencesPath}. {e.Message}");
                return 2;
            }
            catch (FormatException e)
            {
                Console.Error.WriteLine($"Parse error encountered in {EmojiSequencesPath}. {e.Message}");
                return 3;
            }

            try
            {
                using StreamReader emojiZwjSequencesStream = new(EmojiZwjSequencesPath, new FileStreamOptions() { Access = FileAccess.Read, Mode = FileMode.Open });

                emojiZwjSequences = new EmojiZwjSequencesParser(emojiZwjSequencesStream).Parse();
            }
            catch (IOException e)
            {
                Console.Error.WriteLine($"Unable to read from {EmojiZwjSequencesPath}. {e.Message}");
                return 4;
            }
            catch (FormatException e)
            {
                Console.Error.WriteLine($"Parse error encountered in {EmojiSequencesPath}. {e.Message}");
                return 5;
            }

            string outputFilePath = Path.Join(_outputPath, EmojiDotCsPath);

            try
            {
                using StreamWriter emojiDotCsStream = new(outputFilePath, new FileStreamOptions() { Access = FileAccess.Write, Mode = FileMode.Create });

                emojiDotCsStream.Write(
                    EmojiDotCsContent.Replace(
                        "{namespace}",
                        _namespace
                    ).Replace(
                        "{emojiSequences}",
                        emojiSequences.ToCode(EmojiDotCsContentIndent)
                    ).Replace(
                        "{emojiZwjSequences}",
                        emojiZwjSequences.ToCode(EmojiDotCsContentIndent)
                    )
                );
            }
            catch (IOException e)
            {
                Console.Error.WriteLine($"Unable to write to {outputFilePath}. {e.Message}");
                return 6;
            }

            return 0;
        }
    }
}
